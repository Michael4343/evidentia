const fs = require("fs");
const path = require("path");

const LIBRARY_PATH = path.join(__dirname, "../lib/mock-similar-papers.ts");
const PUBLIC_DIR = path.join(__dirname, "../public");
const MOCK_PAPERS_DIR = path.join(PUBLIC_DIR, "mock-papers");
const FALLBACK_ENTRY_ID = "mock-similar-paper";
const MAX_ENTRIES = 5;

function ensureDir(targetDir) {
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }
}

function normaliseId(candidate, fallback) {
  if (typeof candidate === "string") {
    const trimmed = candidate.trim();
    if (trimmed.length > 0) {
      return trimmed;
    }
  }
  return fallback;
}

function buildPublicPath(entryId) {
  return `/mock-papers/${entryId}.pdf`;
}

function clone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj ?? {};
  }
  return JSON.parse(JSON.stringify(obj));
}

function normaliseEntryStructure(rawEntry, fallbackId) {
  const entryId = normaliseId(rawEntry?.id, fallbackId);
  const cloneEntry = clone(rawEntry ?? {});
  cloneEntry.id = entryId;

  const generatedAt = typeof cloneEntry.generatedAt === "string" && cloneEntry.generatedAt.trim().length
    ? cloneEntry.generatedAt.trim()
    : new Date().toISOString();
  const createdAt = typeof cloneEntry.createdAt === "string" && cloneEntry.createdAt.trim().length
    ? cloneEntry.createdAt.trim()
    : generatedAt;
  const updatedAt = typeof cloneEntry.updatedAt === "string" && cloneEntry.updatedAt.trim().length
    ? cloneEntry.updatedAt.trim()
    : generatedAt;

  cloneEntry.createdAt = createdAt;
  cloneEntry.generatedAt = generatedAt;
  cloneEntry.updatedAt = updatedAt;

  const sourcePdf = clone(cloneEntry.sourcePdf ?? {});
  const publicPath = typeof sourcePdf.publicPath === "string" && sourcePdf.publicPath.trim().length
    ? sourcePdf.publicPath.trim()
    : buildPublicPath(entryId);
  sourcePdf.publicPath = publicPath.startsWith("/") ? publicPath : `/${publicPath}`;
  cloneEntry.sourcePdf = sourcePdf;

  if (!cloneEntry.label) {
    const sourceTitle = typeof cloneEntry?.sourcePaper?.title === "string" ? cloneEntry.sourcePaper.title.trim() : "";
    cloneEntry.label = sourceTitle.length > 0 ? sourceTitle : entryId;
  }

  return cloneEntry;
}

function normaliseLibraryStructure(rawLibrary) {
  const base = rawLibrary && typeof rawLibrary === "object" ? rawLibrary : {};

  if (Array.isArray(base.entries)) {
    const entries = base.entries.map((entry, index) => {
      const fallbackId = index === 0 ? FALLBACK_ENTRY_ID : `${FALLBACK_ENTRY_ID}-${index + 1}`;
      return normaliseEntryStructure(entry, fallbackId);
    });
    const defaultEntryId = normaliseId(base.defaultEntryId, entries[0]?.id ?? FALLBACK_ENTRY_ID);
    return {
      version: typeof base.version === "number" ? base.version : 2,
      defaultEntryId,
      entries
    };
  }

  // Legacy single-entry format.
  const entry = normaliseEntryStructure(base, FALLBACK_ENTRY_ID);
  return {
    version: 2,
    defaultEntryId: entry.id,
    entries: [entry]
  };
}

function readLibrary() {
  if (!fs.existsSync(LIBRARY_PATH)) {
    return normaliseLibraryStructure({});
  }

  const fileContents = fs.readFileSync(LIBRARY_PATH, "utf-8");
  const match = fileContents.match(/export const MOCK_SIMILAR_PAPERS_LIBRARY = (\{[\s\S]*\}) as const;/);
  if (!match || !match[1]) {
    throw new Error("Failed to locate mock library export in lib/mock-similar-papers.ts");
  }

  const parsed = JSON.parse(match[1]);
  return normaliseLibraryStructure(parsed);
}

function writeLibrary(scriptFileName, library) {
  ensureDir(path.dirname(LIBRARY_PATH));
  const banner = `// Auto-generated by scripts/${path.basename(scriptFileName)} on ${new Date().toISOString()}\n`;
  const warning = "// Do not edit by hand. Re-run the script with updated inputs.";
  const payload = {
    version: library.version ?? 2,
    defaultEntryId: library.defaultEntryId,
    entries: library.entries
  };
  const fileContents = `${banner}${warning}\n\nexport const MOCK_SIMILAR_PAPERS_LIBRARY = ${JSON.stringify(payload, null, 2)} as const;\n`;
  fs.writeFileSync(LIBRARY_PATH, fileContents, "utf-8");
}

function setDefaultEntry(library, entryId) {
  library.defaultEntryId = entryId;
  library.entries.sort((a, b) => {
    if (a.id === entryId && b.id !== entryId) {
      return -1;
    }
    if (b.id === entryId && a.id !== entryId) {
      return 1;
    }
    const timeA = Date.parse(a.updatedAt ?? "");
    const timeB = Date.parse(b.updatedAt ?? "");
    if (Number.isNaN(timeA) && Number.isNaN(timeB)) {
      return 0;
    }
    if (Number.isNaN(timeA)) {
      return 1;
    }
    if (Number.isNaN(timeB)) {
      return -1;
    }
    return timeB - timeA;
  });
}

function upsertEntry(library, nextEntry) {
  const normalised = normaliseEntryStructure(nextEntry, nextEntry?.id ?? FALLBACK_ENTRY_ID);
  const existingIndex = library.entries.findIndex((entry) => entry.id === normalised.id);
  const isNew = existingIndex === -1;

  if (!Array.isArray(library.entries)) {
    library.entries = [];
  }

  if (!isNew) {
    library.entries[existingIndex] = {
      ...library.entries[existingIndex],
      ...normalised,
      updatedAt: new Date().toISOString()
    };
  } else {
    library.entries.unshift({
      ...normalised,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });
  }

  if (library.entries.length > MAX_ENTRIES) {
    library.entries = library.entries.slice(0, MAX_ENTRIES);
  }

  if (isNew || !library.defaultEntryId) {
    setDefaultEntry(library, normalised.id);
  }

  return normalised.id;
}

function getEntry(library, entryId) {
  return library.entries.find((entry) => entry.id === entryId) ?? null;
}

function listEntries(library) {
  return library.entries.map((entry) => ({
    id: entry.id,
    label: entry.label ?? entry.id,
    title: entry?.sourcePaper?.title ?? entry.label ?? entry.id,
    updatedAt: entry.updatedAt,
    sourcePdf: entry.sourcePdf
  }));
}

function ensureMockPapersDir() {
  ensureDir(MOCK_PAPERS_DIR);
}

function copyPdfToPublic(absolutePdfPath, entryId) {
  ensureMockPapersDir();
  const targetPath = path.join(MOCK_PAPERS_DIR, `${entryId}.pdf`);
  fs.copyFileSync(absolutePdfPath, targetPath);
  return buildPublicPath(entryId);
}

function deleteEntry(library, entryId) {
  const index = library.entries.findIndex((entry) => entry.id === entryId);
  if (index === -1) {
    return false;
  }

  library.entries.splice(index, 1);
  if (library.defaultEntryId === entryId) {
    library.defaultEntryId = library.entries[0]?.id ?? null;
  }

  try {
    const targetPath = path.join(MOCK_PAPERS_DIR, `${entryId}.pdf`);
    if (fs.existsSync(targetPath)) {
      fs.unlinkSync(targetPath);
    }
  } catch (error) {
    console.warn(`Failed to delete public PDF for ${entryId}`, error);
  }

  return true;
}

function slugify(input) {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "")
    .slice(0, 48);
}

function ensureUniqueEntryId(library, proposed) {
  const base = proposed && proposed.trim().length > 0 ? proposed.trim() : slugify(`mock-${Date.now()}`);
  const existingIds = new Set(library.entries.map((entry) => entry.id));
  if (!existingIds.has(base)) {
    return base;
  }
  let attempt = 2;
  while (existingIds.has(`${base}-${attempt}`)) {
    attempt += 1;
  }
  return `${base}-${attempt}`;
}

async function promptForEntrySelection({
  ask,
  library,
  allowCreate = false,
  suggestedId,
  header = "Select a mock entry"
}) {
  if (typeof ask !== "function") {
    throw new Error("promptForEntrySelection requires an ask(question) helper");
  }

  const entries = listEntries(library);

  if (!allowCreate && entries.length === 0) {
    throw new Error("No mock entries available. Run with allowCreate=true to add one.");
  }

  console.log(`\n${header}`);
  entries.forEach((entry, index) => {
    const timestamp = entry.updatedAt ? ` (updated ${entry.updatedAt})` : "";
    console.log(`  [${index + 1}] ${entry.title}${timestamp}`);
  });

  const canCreate = allowCreate;
  if (canCreate) {
    if (library.entries.length >= MAX_ENTRIES) {
      console.log("  [0] Create new entry (oldest entry will be dropped after save)");
    } else {
      console.log("  [0] Create new entry");
    }
  }

  while (true) {
    const raw = await ask("Select an entry by number: ");
    const trimmed = raw.trim();
    if (!trimmed) {
      continue;
    }

    if (/^\d+$/.test(trimmed)) {
      const number = Number.parseInt(trimmed, 10);
      if (number === 0) {
        if (!canCreate) {
          console.log("Creation is disabled for this action.");
          continue;
        }
        const defaultSlug = ensureUniqueEntryId(library, suggestedId ? slugify(suggestedId) : undefined);
        const slugAnswer = await ask(`Enter a slug for the new entry [${defaultSlug}]: `);
        const slug = ensureUniqueEntryId(library, slugAnswer.trim().length ? slugify(slugAnswer) : defaultSlug);
        return { entryId: slug, isNew: true };
      }

      if (number >= 1 && number <= entries.length) {
        return { entryId: entries[number - 1].id, isNew: false };
      }

      console.log("Invalid selection. Try again.");
      continue;
    }

    const match = entries.find((entry) => entry.id === trimmed);
    if (match) {
      return { entryId: match.id, isNew: false };
    }

    console.log("Unable to resolve selection. Provide a valid number or entry ID.");
  }
}

module.exports = {
  LIBRARY_PATH,
  FALLBACK_ENTRY_ID,
  MAX_ENTRIES,
  readLibrary,
  writeLibrary,
  setDefaultEntry,
  upsertEntry,
  getEntry,
  listEntries,
  copyPdfToPublic,
  deleteEntry,
  buildPublicPath,
  slugify,
  ensureMockPapersDir,
  normaliseLibraryStructure,
  ensureUniqueEntryId,
  promptForEntrySelection
};
