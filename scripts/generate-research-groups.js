#!/usr/bin/env node

/**
 * Interactive helper for generating Research Groups narratives.
 *
 * Usage:
 *   node scripts/generate-research-groups.js
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");
const clipboardModule = require("clipboardy");
const clipboardy = clipboardModule?.default ?? clipboardModule;
const pdfParse = require("pdf-parse");

const DEFAULT_OUTPUT_PATH = path.join(__dirname, "../lib/mock-similar-papers.ts");
const PUBLIC_SAMPLE_PDF_PATH = path.join(__dirname, "../public/mock-paper.pdf");
const MAX_INPUT_CHARS = 8_000; // mirrors /api/research-groups limit
const MAX_LISTED_PDFS = 40;
const MAX_SCAN_DEPTH = 3;
const IGNORED_DIRS = new Set(["node_modules", ".git", ".next", "out", "dist", "build", "tmp", "temp", "public"]);

const RESEARCH_GROUPS_BASE_PROMPT = `You are assisting a researcher who just uploaded the following paper. Read the paper carefully and identify its core themes, methods, and subject domains. The paper context below is the primary signal; only include research groups whose recent work directly overlaps the paper’s topics.

Task:
Find and rank up to five current (active within the last 3–5 years) research groups or independent organisations whose published work is tightly aligned with this paper. Use web search only to confirm activity and surface supporting details; do not include unrelated groups.

For each group, include:
- Group name and affiliated institution
- One-sentence explanation of how their focus connects to the paper (reference the specific overlap you saw in the extracted text)
- One recent publication, project, or initiative (2021 or later) showing the overlap, with year and citation if available
- Contact information or URL if available

Also provide:
- A 1–2 sentence summary of the paper themes that guided your search
- A ranked list explanation (why each group is ordered the way it is)
- A short note if web results were sparse or older than 2021

Output in plain text with clear section headers and bullet lists. Keep the overall answer under roughly 280 tokens. If no groups match, state that explicitly and explain why.`;

const CURLY_QUOTES_TO_ASCII = [
  [/\u2018|\u2019|\u201A|\u201B/g, "'"],
  [/\u201C|\u201D|\u201E|\u201F/g, '"'],
  [/\u2013|\u2014|\u2015|\u2212/g, "-"],
  [/\u2026/g, "..."],
  [/\u00A0/g, " "],
  [/\u200B|\u200C|\u200D|\uFEFF/g, ""],
  [/\u0000|\u0001|\u0002|\u0003|\u0004|\u0005|\u0006|\u0007|\u0008|\u0009|\u000A|\u000B|\u000C|\u000D/g, " "]
];

function cleanPlainText(input) {
  if (typeof input !== "string") {
    return input;
  }

  let value = input.replace(/\r\n/g, "\n").trim();
  for (const [pattern, replacement] of CURLY_QUOTES_TO_ASCII) {
    value = value.replace(pattern, replacement);
  }

  value = value.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (match, label, url) => `${label} (${url})`);
  value = value.replace(/\[(\d+|[a-zA-Z]+)\]/g, " $1");

  value = value
    .split("\n")
    .map((line) => line.trim())
    .filter((line, index, lines) => line.length > 0 || (index > 0 && lines[index - 1].length > 0))
    .join("\n");

  return value.trim();
}

function normaliseDoi(raw) {
  return raw.replace(/[\s<>\]\).,;:]+$/g, "").replace(/^[\s"'(<\[]+/g, "").toLowerCase();
}

function extractDoiCandidate(text) {
  const DOI_REGEX = /10\.\d{4,9}\/[\-._;()/:a-z0-9]+/gi;
  const matches = text.match(DOI_REGEX);
  if (matches && matches.length > 0) {
    return normaliseDoi(matches[0]);
  }
  return null;
}

function truncateForPrompt(text, limit) {
  if (!text || text.length <= limit) {
    return { clipped: text || "", truncated: false };
  }

  return {
    clipped: `${text.slice(0, limit)}\n\n[Truncated input to ${limit} characters for the request]`,
    truncated: true
  };
}

function derivePaperMetadata(info, fallbackTitle, detectedDoi) {
  const authors = info?.Author || info?.Authors || info?.Creator || null;
  const abstract = info?.Subject || info?.Keywords || null;

  return {
    title: info?.Title && info.Title.trim().length ? info.Title.trim() : fallbackTitle,
    doi: detectedDoi,
    url: null,
    scraped_url: null,
    authors,
    abstract
  };
}

function ensureDirExists(targetPath) {
  const dir = path.dirname(targetPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function writeMockLibrary(outputPath, libraryData) {
  ensureDirExists(outputPath);
  const banner = `// Auto-generated by scripts/${path.basename(__filename)} on ${new Date().toISOString()}\n`;
  const warning = "// Do not edit by hand. Re-run the script with updated inputs.";
  const fileContents = `${banner}${warning}\n\nexport const MOCK_SIMILAR_PAPERS_LIBRARY = ${JSON.stringify(libraryData, null, 2)} as const;\n`;
  fs.writeFileSync(outputPath, fileContents, "utf-8");
}

function readExistingLibrary(outputPath) {
  if (!fs.existsSync(outputPath)) {
    return null;
  }

  try {
    const fileContents = fs.readFileSync(outputPath, "utf-8");
    const match = fileContents.match(/export const MOCK_SIMILAR_PAPERS_LIBRARY = (\{[\s\S]*\}) as const;/);
    if (!match || !match[1]) {
      return null;
    }
    return JSON.parse(match[1]);
  } catch (error) {
    console.warn("Failed to read existing mock library", error);
    return null;
  }
}

function findPdfFiles(rootDir, maxDepth = MAX_SCAN_DEPTH, limit = MAX_LISTED_PDFS) {
  const results = [];

  function walk(currentDir, depth) {
    if (results.length >= limit) {
      return;
    }
    if (depth > maxDepth) {
      return;
    }

    let entries = [];
    try {
      entries = fs.readdirSync(currentDir, { withFileTypes: true });
    } catch (error) {
      return;
    }

    for (const entry of entries) {
      if (results.length >= limit) {
        break;
      }
      if (entry.name.startsWith(".")) {
        continue;
      }

      const fullPath = path.join(currentDir, entry.name);
      if (entry.isDirectory()) {
        if (!IGNORED_DIRS.has(entry.name)) {
          walk(fullPath, depth + 1);
        }
        continue;
      }

      if (entry.isFile() && entry.name.toLowerCase().endsWith(".pdf")) {
        results.push({
          relative: path.relative(rootDir, fullPath) || entry.name,
          absolute: fullPath
        });
      }
    }
  }

  walk(rootDir, 0);
  return results;
}

function createInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
}

function ask(rl, question) {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer);
    });
  });
}

async function promptForPdfPath(rl, rootDir) {
  const pdfFiles = findPdfFiles(rootDir);

  if (pdfFiles.length > 0) {
    console.log(`\nFound ${pdfFiles.length} PDF${pdfFiles.length === 1 ? "" : "s"} within ${path.basename(rootDir) || "."}:`);
    pdfFiles.forEach((file, index) => {
      console.log(`  [${index + 1}] ${file.relative}`);
    });
    console.log("  [0] Enter a custom path");

    while (true) {
      const answer = await ask(rl, "\nSelect a PDF by number (or type a custom path): ");
      const trimmed = answer.trim();
      if (!trimmed) {
        continue;
      }

      if (/^\d+$/.test(trimmed)) {
        const index = Number.parseInt(trimmed, 10);
        if (index === 0) {
          break;
        }
        if (index >= 1 && index <= pdfFiles.length) {
          return pdfFiles[index - 1].absolute;
        }
        console.log("Invalid selection. Try again.");
        continue;
      }

      const resolved = path.resolve(rootDir, trimmed);
      if (fs.existsSync(resolved) && resolved.toLowerCase().endsWith(".pdf")) {
        return resolved;
      }
      console.log("Path does not point to a PDF. Try again.");
    }
  }

  while (true) {
    const manual = await ask(rl, "Enter the path to a PDF: ");
    const resolved = path.resolve(rootDir, manual.trim());
    if (fs.existsSync(resolved) && resolved.toLowerCase().endsWith(".pdf")) {
      return resolved;
    }
    console.log("Could not find that PDF. Please try again.");
  }
}

async function collectResearchGroupsText(rl) {
  console.log("\nPaste the research groups response. Press ENTER on an empty line when you're done.");
  console.log("Press ENTER immediately to skip when you don't have output yet.\n");

  const lines = [];
  while (true) {
    const line = await ask(rl, "> ");
    const trimmed = line.trim();
    if (lines.length === 0 && !trimmed) {
      return "";
    }
    if (!trimmed) {
      break;
    }
    if (trimmed.toUpperCase() === "END") {
      break;
    }
    lines.push(line);
  }

  return lines.join("\n").trim();
}

async function buildResearchPromptFromPdf(pdfPath) {
  const pdfBuffer = fs.readFileSync(pdfPath);
  const data = await pdfParse(pdfBuffer);
  const info = data.info || {};
  const combinedText = data.text || "";
  const fallbackTitle = path.basename(pdfPath, path.extname(pdfPath));
  const detectedDoi = extractDoiCandidate(`${combinedText}\n${JSON.stringify(info)}`);
  const paper = derivePaperMetadata(info, fallbackTitle, detectedDoi);

  const { clipped, truncated } = truncateForPrompt(combinedText, MAX_INPUT_CHARS);
  const title = paper.title && paper.title.trim().length > 0 ? paper.title.trim() : "Unknown";
  const doi = paper.doi && paper.doi.trim().length > 0 ? paper.doi.trim() : "Unknown";

  const contextLines = [
    "Paper context:",
    `• Title: ${title}`,
    `• DOI: ${doi}`,
    truncated ? "• Note: PDF text truncated to fit request limits." : null
  ].filter(Boolean);

  const assembledPrompt = [
    RESEARCH_GROUPS_BASE_PROMPT,
    contextLines.join("\n"),
    `Extracted paper text:\n${clipped}`
  ].join("\n\n");

  return {
    prompt: assembledPrompt,
    truncated,
    context: {
      title: paper.title,
      detectedDoi,
      pageCount: data.numpages,
      truncated,
      authors: paper.authors,
      abstract: paper.abstract
    }
  };
}

async function run() {
  const rl = createInterface();
  const workingDir = process.cwd();

  try {
    console.log("\n=== Research Groups Prototype Helper ===\n");
    console.log(`Working directory: ${workingDir}`);

    const pdfPath = await promptForPdfPath(rl, workingDir);
    console.log(`\nUsing PDF: ${pdfPath}`);

    const outputPath = path.resolve(workingDir, DEFAULT_OUTPUT_PATH);
    const existingLibrary = readExistingLibrary(outputPath);

    if (!existingLibrary) {
      console.error("\n❌ No existing mock library found. Run the Similar Papers generator first.");
      return;
    }

    const { prompt, truncated, context } = await buildResearchPromptFromPdf(pdfPath);

    await clipboardy.write(prompt);

    console.log("\nResearch Groups prompt copied to your clipboard. Paste it into the deep research agent.\n");
    if (truncated) {
      console.log(`Note: extracted text was clipped to ${MAX_INPUT_CHARS.toLocaleString()} characters to match the API limit.`);
    }
    console.log("Preview:");
    console.log(`${prompt.slice(0, 240)}${prompt.length > 240 ? "…" : ""}`);
    console.log(
      "\nNext steps:\n  1. Paste the prompt into your deep research agent.\n  2. Wait for the narrative response.\n  3. Paste the text back here (press ENTER on an empty line when finished).\n"
    );

    const researchGroupsRaw = await collectResearchGroupsText(rl);

    if (!researchGroupsRaw) {
      console.log("No research groups narrative provided. Mock library left unchanged.");
      return;
    }

    const researchGroupsData = {
      maxChars: MAX_INPUT_CHARS,
      truncated,
      text: cleanPlainText(researchGroupsRaw)
    };

    const libraryData = {
      ...existingLibrary,
      generatedAt: new Date().toISOString(),
      sourcePdf: {
        path: path.relative(path.join(__dirname, ".."), pdfPath),
        title: context.title,
        doi: context.detectedDoi,
        pages: context.pageCount
      },
      researchGroups: researchGroupsData
    };

    writeMockLibrary(outputPath, libraryData);

    try {
      ensureDirExists(PUBLIC_SAMPLE_PDF_PATH);
      fs.copyFileSync(pdfPath, PUBLIC_SAMPLE_PDF_PATH);
      console.log(`Copied PDF to ${path.relative(workingDir, PUBLIC_SAMPLE_PDF_PATH)}`);
    } catch (copyError) {
      console.warn("Failed to copy PDF into public/mock-paper.pdf", copyError);
    }

    console.log(`\nMock library updated: ${path.relative(workingDir, DEFAULT_OUTPUT_PATH)}`);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`\n❌ ${message}`);
    process.exitCode = 1;
  } finally {
    rl.close();
  }
}

run();
