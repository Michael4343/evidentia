#!/usr/bin/env node

/**
 * Interactive helper for assembling patent search prompts.
 *
 * Usage:
 *   node scripts/generate-patents.js
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");
const clipboardModule = require("clipboardy");
const clipboardy = clipboardModule?.default ?? clipboardModule;

const DEFAULT_OUTPUT_PATH = path.join(__dirname, "../lib/mock-similar-papers.ts");

const CLEANUP_PROMPT_HEADER = `You are a cleanup agent. Convert the analyst's patent search notes into strict JSON for Evidentia's patent UI.

Output requirements:
- Return a single JSON object with keys: patents (array), promptNotes (optional string).
- Each patent object must include: patentNumber (string), title (string), assignee (string|null), filingDate (string|null), grantDate (string|null), abstract (string|null), overlapWithPaper (object with claimIds array and summary string), url (string|null).
- Use null for unknown scalars. Use empty arrays for missing arrays.
- Every url field must be a direct https:// link to the patent (Google Patents, USPTO, etc.).
- Dates should be in YYYY-MM-DD format when available.
- overlapWithPaper.claimIds should reference the paper claim IDs (e.g., ["C1", "C3"]).
- overlapWithPaper.summary MUST be a detailed 2-3 sentence explanation of HOW the patent's technical claims map to specific methods/techniques in the paper. Be specific about the technical overlap.
- No markdown, commentary, or trailing prose. Valid JSON only (double quotes).
- Preserve factual content from the notes; do not invent new patents.
- Output raw JSON only — no markdown fences, comments, trailing prose, or extra keys.`;

const CURLY_QUOTES_TO_ASCII = [
  [/\u2018|\u2019|\u201A|\u201B/g, "'"],
  [/\u201C|\u201D|\u201E|\u201F/g, '"'],
  [/\u2013|\u2014|\u2015|\u2212/g, "-"],
  [/\u2026/g, "..."],
  [/\u00A0/g, " "],
  [/\u200B|\u200C|\u200D|\uFEFF/g, ""],
  [/\u0000|\u0001|\u0002|\u0003|\u0004|\u0005|\u0006|\u0007|\u0008|\u0009|\u000A|\u000B|\u000C|\u000D/g, " "]
];

function cleanPlainText(input) {
  if (typeof input !== "string") {
    return input;
  }

  let value = input.replace(/\r\n/g, "\n").trim();
  for (const [pattern, replacement] of CURLY_QUOTES_TO_ASCII) {
    value = value.replace(pattern, replacement);
  }

  value = value.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (match, label, url) => `${label} (${url})`);
  value = value.replace(/\[(\d+|[a-zA-Z]+)\]/g, " $1");

  value = value
    .split("\n")
    .map((line) => line.trim())
    .filter((line, index, lines) => line.length > 0 || (index > 0 && lines[index - 1].length > 0))
    .join("\n");

  return value.trim();
}

function ensureDirExists(targetPath) {
  const dir = path.dirname(targetPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function writeMockLibrary(outputPath, libraryData) {
  ensureDirExists(outputPath);
  const banner = `// Auto-generated by scripts/${path.basename(__filename)} on ${new Date().toISOString()}\n`;
  const warning = "// Do not edit by hand. Re-run the script with updated inputs.";
  const fileContents = `${banner}${warning}\n\nexport const MOCK_SIMILAR_PAPERS_LIBRARY = ${JSON.stringify(libraryData, null, 2)} as const;\n`;
  fs.writeFileSync(outputPath, fileContents, "utf-8");
}

function readExistingLibrary(outputPath) {
  if (!fs.existsSync(outputPath)) {
    return null;
  }

  try {
    const fileContents = fs.readFileSync(outputPath, "utf-8");
    const match = fileContents.match(/export const MOCK_SIMILAR_PAPERS_LIBRARY = (\{[\s\S]*\}) as const;/);
    if (!match || !match[1]) {
      return null;
    }
    return JSON.parse(match[1]);
  } catch (error) {
    console.warn("Failed to read existing mock library", error);
    return null;
  }
}

function createInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
}

function ask(rl, question) {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer);
    });
  });
}

async function collectCleanedJson(rl) {
  console.log("\nPaste the cleaned JSON now. Press ENTER on an empty line when you're done.");
  console.log("Press ENTER immediately to skip when you don't have output yet.\n");

  const lines = [];
  while (true) {
    const line = await ask(rl, "> ");
    const trimmed = line.trim();
    if (lines.length === 0 && !trimmed) {
      return "";
    }
    if (!trimmed) {
      break;
    }
    if (trimmed.toUpperCase() === "END") {
      break;
    }
    lines.push(line);
  }

  return lines.join("\n").trim();
}

function buildPatentDiscoveryPrompt(library) {
  const claimsAnalysis = library?.claimsAnalysis;

  if (!claimsAnalysis || !claimsAnalysis.structured || !Array.isArray(claimsAnalysis.structured.claims)) {
    throw new Error(
      "No claims analysis found in mock library. Run the claims analysis script first."
    );
  }

  const claims = claimsAnalysis.structured.claims;
  const paperTitle = library?.sourcePaper?.title || library?.sourcePdf?.title || "Unknown paper";
  const paperDoi = library?.sourcePdf?.doi || library?.sourcePaper?.doi || "";

  if (claims.length === 0) {
    throw new Error("No claims found in the analysis. Cannot generate patent search prompt.");
  }

  const lines = [
    "You are a patent research analyst.",
    "",
    "Search for Patents Covering Methods, Compositions, or Systems Described in Paper Claims",
    "",
    `Paper: ${paperTitle}`,
  ];

  if (paperDoi) {
    lines.push(`DOI: ${paperDoi}`);
  }

  lines.push(
    "",
    "Goal: For each claim below, identify relevant patents that cover similar methods, compositions, systems, or applications. Focus on granted patents and published applications that overlap with the technical approaches described. Provide rigorous technical analysis of how patent claims map to specific paper methods.",
    "",
    "Methodology:",
    "1. For each paper claim, extract specific technical elements:",
    "   - Algorithms, computational methods, or analytical approaches",
    "   - Compositions, materials, or chemical structures",
    "   - Apparatus, devices, or instrumentation",
    "   - Applications, use cases, or therapeutic methods",
    "2. Search patent databases (Google Patents, USPTO, EPO, WIPO) for patents covering those elements.",
    "3. For each patent found, perform technical claim mapping:",
    "   - Identify which specific patent claims cover similar approaches",
    "   - Map patent claim language to paper's technical elements",
    "   - Explain HOW the patent claims cover the paper's methods (be specific)",
    "   - Note both broad coverage and narrow technical overlap",
    "4. Prioritize patents with substantive technical overlap, not just keyword matches.",
    "5. For each patent, write a 2-3 sentence technical summary explaining the overlap.",
    "",
    "Claims from the paper:",
    ""
  );

  claims.forEach((claim) => {
    lines.push(`${claim.id}: ${claim.claim}`);
    if (claim.evidenceSummary) {
      lines.push(`   Evidence: ${claim.evidenceSummary}`);
    }
    if (claim.evidenceType) {
      lines.push(`   Type: ${claim.evidenceType}`);
    }
    lines.push("");
  });

  lines.push(
    "Deliverable:",
    "- Return plain text with one section per patent found.",
    "- For each patent, provide:",
    "  * Patent number (e.g., US1234567, EP9876543, WO2020123456)",
    "  * Title",
    "  * Assignee (company/institution)",
    "  * Filing date and grant date (if granted)",
    "  * Brief abstract (1-2 sentences)",
    "  * Which paper claims this patent relates to (e.g., C1, C3)",
    "  * Technical overlap summary (2-3 sentences explaining HOW the patent claims map to specific paper methods/techniques)",
    "  * URL to patent document (Google Patents, USPTO, etc.)",
    "- Include 5-10 most relevant patents with substantive technical overlap.",
    "- Focus on quality over quantity - only include patents with clear technical mapping.",
    "- If no patents are found for certain claims, note that explicitly.",
    ""
  );

  return lines.join("\n");
}

function buildCleanupPrompt() {
  return [
    CLEANUP_PROMPT_HEADER.trim(),
    "",
    "Refer to the analyst notes in the previous message (do not paste them here).",
    "---",
    "[Notes already provided above]",
    "---",
    "Return the JSON object now."
  ].join("\n");
}

function normalizePatent(entry) {
  if (!entry || typeof entry !== "object") {
    return null;
  }

  const patentNumber = cleanPlainText(entry.patentNumber || "");
  if (!patentNumber) {
    return null;
  }

  const title = cleanPlainText(entry.title || "");
  const assignee = entry.assignee ? cleanPlainText(entry.assignee) : null;
  const filingDate = typeof entry.filingDate === "string" ? entry.filingDate.trim() : null;
  const grantDate = typeof entry.grantDate === "string" ? entry.grantDate.trim() : null;
  const abstract = entry.abstract ? cleanPlainText(entry.abstract) : null;
  const url = typeof entry.url === "string" && entry.url.trim().startsWith("http") ? entry.url.trim() : null;

  const overlapWithPaper = entry.overlapWithPaper && typeof entry.overlapWithPaper === "object"
    ? {
        claimIds: Array.isArray(entry.overlapWithPaper.claimIds)
          ? entry.overlapWithPaper.claimIds.filter((id) => typeof id === "string" && id.trim().length > 0)
          : [],
        summary: entry.overlapWithPaper.summary ? cleanPlainText(entry.overlapWithPaper.summary) : ""
      }
    : { claimIds: [], summary: "" };

  return {
    patentNumber,
    title: title || "Untitled patent",
    assignee,
    filingDate,
    grantDate,
    abstract,
    overlapWithPaper,
    url
  };
}

function normalizePatentsPayload(payload) {
  if (!payload || typeof payload !== "object") {
    throw new Error("Cleanup agent response must be a JSON object.");
  }

  if (!Array.isArray(payload.patents)) {
    throw new Error("patents must be an array.");
  }

  const patents = payload.patents
    .map((entry) => normalizePatent(entry))
    .filter(Boolean);

  const promptNotes = typeof payload.promptNotes === "string" ? cleanPlainText(payload.promptNotes) : "";

  return {
    patents,
    promptNotes
  };
}

function formatPatents(patents) {
  return patents
    .map((patent) => {
      const lines = [
        `Patent: ${patent.patentNumber}`,
        `Title: ${patent.title}`,
        `Assignee: ${patent.assignee || "Not provided"}`,
        `Filing Date: ${patent.filingDate || "Not provided"}`,
        `Grant Date: ${patent.grantDate || "Not provided"}`,
      ];

      if (patent.abstract) {
        lines.push(`Abstract: ${patent.abstract}`);
      }

      if (patent.overlapWithPaper.claimIds.length > 0) {
        lines.push(`Overlaps with paper claims: ${patent.overlapWithPaper.claimIds.join(", ")}`);
      }

      if (patent.overlapWithPaper.summary) {
        lines.push(`Technical overlap: ${patent.overlapWithPaper.summary}`);
      }

      if (patent.url) {
        lines.push(`URL: ${patent.url}`);
      }

      return lines.join("\n");
    })
    .join("\n\n");
}

async function run() {
  const rl = createInterface();
  const workingDir = process.cwd();

  try {
    console.log("\n=== Patent Search Prompt Helper ===\n");
    console.log(`Working directory: ${workingDir}`);

    const outputPath = path.resolve(workingDir, DEFAULT_OUTPUT_PATH);
    const existingLibrary = readExistingLibrary(outputPath);

    if (!existingLibrary) {
      console.error("\n❌ No existing mock library found. Run the Similar Papers generator first.");
      return;
    }

    if (!existingLibrary.claimsAnalysis) {
      console.error("\n❌ Claims analysis data missing. Run the claims analysis generator to capture claims before searching for patents.");
      return;
    }

    const discoveryPrompt = buildPatentDiscoveryPrompt(existingLibrary);
    await clipboardy.write(discoveryPrompt);

    console.log("\nPatent discovery prompt copied to your clipboard. Paste it into your research agent to gather patent notes.\n");
    console.log("Preview:");
    console.log(`${discoveryPrompt.slice(0, 240)}${discoveryPrompt.length > 240 ? "…" : ""}`);
    console.log(
      "\nNext steps:\n  1. Paste the prompt into your research agent and let it complete.\n  2. Collect the patent notes.\n  3. Press ENTER here when you're ready for the cleanup prompt.\n"
    );

    await ask(rl, "\nPress ENTER once the notes are ready to receive the cleanup prompt: ");

    const cleanupPrompt = buildCleanupPrompt();
    await clipboardy.write(cleanupPrompt);

    console.log("\nCleanup prompt copied to your clipboard. Paste it into the cleanup agent, add the notes beneath the divider, and request JSON.\n");
    console.log("Preview:");
    console.log(`${cleanupPrompt.slice(0, 240)}${cleanupPrompt.length > 240 ? "…" : ""}`);
    console.log(
      "\nNext steps:\n  1. Paste the cleanup prompt into your LLM.\n  2. Add the discovery notes beneath the placeholder line, then run the cleanup.\n  3. Paste the cleaned JSON back here (press ENTER on an empty line when finished).\n"
    );

    const cleanedJsonRaw = await collectCleanedJson(rl);

    if (!cleanedJsonRaw) {
      console.log("No cleaned JSON provided. Mock library left unchanged.");
      return;
    }

    let cleanedPayload;
    try {
      cleanedPayload = JSON.parse(cleanedJsonRaw);
    } catch (error) {
      console.error("\n❌ Failed to parse the patents JSON. Ensure the cleanup agent returns valid JSON only.");
      console.error("Raw snippet preview:");
      console.error(cleanedJsonRaw.slice(0, 200));
      throw new Error(`Failed to parse patents JSON: ${error instanceof Error ? error.message : String(error)}`);
    }

    const normalised = normalizePatentsPayload(cleanedPayload);
    const formattedText = formatPatents(normalised.patents);

    const patentsData = {
      text: formattedText,
      structured: {
        patents: normalised.patents,
        promptNotes: normalised.promptNotes
      }
    };

    const libraryData = {
      ...existingLibrary,
      generatedAt: new Date().toISOString(),
      patents: patentsData
    };

    writeMockLibrary(outputPath, libraryData);

    console.log(`\nMock library updated with patents: ${path.relative(workingDir, DEFAULT_OUTPUT_PATH)}`);
    console.log(`\nFound ${normalised.patents.length} patent(s).`);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`\n❌ ${message}`);
    process.exitCode = 1;
  } finally {
    rl.close();
  }
}

run();
