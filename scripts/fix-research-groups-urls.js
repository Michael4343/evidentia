#!/usr/bin/env node

/**
 * One-time fix script to clean malformed URLs in mock-similar-papers.ts
 *
 * This script fixes URLs with the pattern "url](url" that were generated
 * by the LLM in markdown format instead of plain text.
 *
 * Usage:
 *   node scripts/fix-research-groups-urls.js
 */

const fs = require('fs');
const path = require('path');
const { cleanUrlStrict } = require('../lib/clean-url-strict.js');

const MOCK_LIBRARY_PATH = path.join(__dirname, '../lib/mock-similar-papers.ts');

/**
 * Read the existing mock library from the TypeScript file
 */
function readExistingLibrary(filePath) {
  if (!fs.existsSync(filePath)) {
    throw new Error(`File not found: ${filePath}`);
  }

  const fileContents = fs.readFileSync(filePath, 'utf-8');
  const match = fileContents.match(/export const MOCK_SIMILAR_PAPERS_LIBRARY = (\{[\s\S]*\}) as const;/);

  if (!match || !match[1]) {
    throw new Error('Could not parse MOCK_SIMILAR_PAPERS_LIBRARY from file');
  }

  return JSON.parse(match[1]);
}

/**
 * Write the cleaned library back to the TypeScript file
 */
function writeLibrary(filePath, libraryData) {
  const banner = `// Auto-generated by scripts/${path.basename(__filename)} on ${new Date().toISOString()}\n`;
  const warning = '// Do not edit by hand. Re-run the script with updated inputs.';
  const fileContents = `${banner}${warning}\n\nexport const MOCK_SIMILAR_PAPERS_LIBRARY = ${JSON.stringify(libraryData, null, 2)} as const;\n`;

  fs.writeFileSync(filePath, fileContents, 'utf-8');
}

/**
 * Format research groups text (mirrors function from generate-research-groups.js)
 */
function formatResearchGroups(papers) {
  return papers
    .map((paper) => {
      const header = [`Paper: ${paper.title}${paper.identifier ? ` (${paper.identifier})` : ''}`];
      const groupBlocks = paper.groups.length
        ? paper.groups.map((group) => {
            const groupHeader = [
              `Group: ${group.name}${group.institution ? ` (${group.institution})` : ''}`,
              group.website ? `Website: ${group.website}` : 'Website: Not provided',
              group.notes && group.notes.length > 0 ? `Summary: ${group.notes}` : 'Summary: Not provided'
            ];

            const researcherRows = group.researchers.length
              ? group.researchers
              : [{ name: 'Not provided', email: null, role: null }];

            const tableLines = ['| Name | Email | Role |', '| --- | --- | --- |'];
            researcherRows.forEach((person) => {
              const email = person.email || 'Not provided';
              const role = person.role || 'Not provided';
              tableLines.push(`| ${person.name} | ${email} | ${role} |`);
            });

            return `${groupHeader.join('\n')}\n${tableLines.join('\n')}`;
          })
        : ['No groups reported'];

      return `${header.join('\n')}\n${groupBlocks.join('\n\n')}`;
    })
    .join('\n\n');
}

/**
 * Clean all URLs in the research groups data
 */
function cleanResearchGroupsUrls(library) {
  let fixCount = 0;
  const examples = [];

  if (library.researchGroups && library.researchGroups.structured && Array.isArray(library.researchGroups.structured.papers)) {
    library.researchGroups.structured.papers.forEach((paper) => {
      if (Array.isArray(paper.groups)) {
        paper.groups.forEach((group) => {
          if (group.website && typeof group.website === 'string') {
            const original = group.website;
            const cleaned = cleanUrlStrict(group.website);

            if (original !== cleaned) {
              fixCount++;
              if (examples.length < 5) {
                examples.push({ original, cleaned, group: group.name });
              }
              group.website = cleaned;
            }
          }
        });
      }
    });

    // Regenerate the text representation with cleaned URLs
    library.researchGroups.text = formatResearchGroups(library.researchGroups.structured.papers);
  }

  return { fixCount, examples };
}

/**
 * Format researcher theses text (mirrors function from generate-researcher-theses.js)
 */
function formatResearcherTheses(researchers) {
  return researchers
    .map((researcher) => {
      const lines = [
        `Researcher: ${researcher.name}${researcher.group ? ` — ${researcher.group}` : ''}`,
        `Email: ${researcher.email || 'Not provided'}`,
        `Data publicly available: ${researcher.data_publicly_available}`
      ];

      const pub = researcher.latest_publication || {};
      lines.push('Latest publication:');
      lines.push(`  - Title: ${pub.title || 'Not found'}`);
      lines.push(`  - Year: ${typeof pub.year === 'number' ? pub.year : 'Not found'}`);
      lines.push(`  - Venue: ${pub.venue || 'Not found'}`);
      lines.push(`  - URL: ${pub.url || 'Not found'}`);

      if (researcher.phd_thesis) {
        const thesis = researcher.phd_thesis;
        lines.push('PhD thesis:');
        lines.push(`  - Title: ${thesis.title || 'Not found'}`);
        lines.push(`  - Year: ${typeof thesis.year === 'number' ? thesis.year : 'Not found'}`);
        lines.push(`  - Institution: ${thesis.institution || 'Not found'}`);
        lines.push(`  - URL: ${thesis.url || 'Not found'}`);
      } else {
        lines.push('PhD thesis: Not found');
      }

      return lines.join('\n');
    })
    .join('\n\n');
}

/**
 * Clean all URLs in the researcher theses data
 */
function cleanResearcherThesesUrls(library) {
  let fixCount = 0;
  const examples = [];

  if (library.researcherTheses && library.researcherTheses.structured && Array.isArray(library.researcherTheses.structured.researchers)) {
    library.researcherTheses.structured.researchers.forEach((researcher) => {
      if (researcher.latest_publication && researcher.latest_publication.url) {
        const original = researcher.latest_publication.url;
        const cleaned = cleanUrlStrict(researcher.latest_publication.url);

        if (original !== cleaned) {
          fixCount++;
          if (examples.length < 3) {
            examples.push({ original, cleaned, researcher: researcher.name });
          }
          researcher.latest_publication.url = cleaned;
        }
      }

      if (researcher.phd_thesis && researcher.phd_thesis.url) {
        const original = researcher.phd_thesis.url;
        const cleaned = cleanUrlStrict(researcher.phd_thesis.url);

        if (original !== cleaned) {
          fixCount++;
          if (examples.length < 3) {
            examples.push({ original, cleaned, researcher: researcher.name });
          }
          researcher.phd_thesis.url = cleaned;
        }
      }
    });

    // Regenerate the text representation with cleaned URLs
    library.researcherTheses.text = formatResearcherTheses(library.researcherTheses.structured.researchers);
  }

  return { fixCount, examples };
}

/**
 * Main execution
 */
function run() {
  console.log('\n=== Fix Malformed URLs in Research Groups Data ===\n');

  try {
    // Read existing library
    console.log(`Reading: ${MOCK_LIBRARY_PATH}`);
    const library = readExistingLibrary(MOCK_LIBRARY_PATH);

    // Clean research groups URLs
    console.log('\nCleaning Research Groups URLs...');
    const groupsResult = cleanResearchGroupsUrls(library);
    console.log(`  Fixed ${groupsResult.fixCount} URLs in research groups`);

    if (groupsResult.examples.length > 0) {
      console.log('\n  Examples:');
      groupsResult.examples.forEach(({ original, cleaned, group }) => {
        console.log(`    Group: ${group}`);
        console.log(`      Before: ${original}`);
        console.log(`      After:  ${cleaned}\n`);
      });
    }

    // Clean researcher theses URLs
    console.log('Cleaning Researcher Theses URLs...');
    const thesesResult = cleanResearcherThesesUrls(library);
    console.log(`  Fixed ${thesesResult.fixCount} URLs in researcher theses`);

    if (thesesResult.examples.length > 0) {
      console.log('\n  Examples:');
      thesesResult.examples.forEach(({ original, cleaned, researcher }) => {
        console.log(`    Researcher: ${researcher}`);
        console.log(`      Before: ${original}`);
        console.log(`      After:  ${cleaned}\n`);
      });
    }

    // Update timestamp
    library.generatedAt = new Date().toISOString();

    // Write back to file
    console.log('Writing cleaned data back to file...');
    writeLibrary(MOCK_LIBRARY_PATH, library);

    console.log(`\n✓ Success! Fixed ${groupsResult.fixCount + thesesResult.fixCount} total URLs`);
    console.log(`  Output: ${MOCK_LIBRARY_PATH}\n`);

  } catch (error) {
    console.error(`\n✗ Error: ${error.message}\n`);
    process.exitCode = 1;
  }
}

run();
